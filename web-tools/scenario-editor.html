<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Редактор Сценариев v30.3 (Исправлено)</title>

    <!-- Fonts (unified with other editors) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Tailwind (CDN). Load shared config BEFORE tailwindcss. -->
    <script src="editor-core/tailwind-theme.js"></script>
    <script src="https://cdn.tailwindcss.com?plugins=forms"></script>
    
    <!-- Иконки Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <link rel="stylesheet" href="editor-core/editor-theme.css">
    <link rel="stylesheet" href="editor-core/editor-template.css">
    
    <!-- Библиотека для Drag-and-Drop -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    
    <style>
        /* Небольшие кастомные стили */
        :root{ --scenario-header-h: 70px; }

        /* Scenario header should stay in one line; overflow scroll instead of wrapping */
        #scenario-header{ overflow-x: auto; }
        #scenario-header, #scenario-header *{ scroll-margin-top: var(--scenario-header-h); }
        #scenario-header .controls{ flex-wrap: nowrap; }
        #scenario-header .controls > *{ flex: 0 0 auto; }
        #scenario-header select, #scenario-header input{ width: clamp(160px, 18vw, 260px); }

        /* Keep the navigator aligned with the real header height (fixes wrap/overlap issues). */
        @media (min-width: 768px){
          #navigator{ top: var(--scenario-header-h); height: calc(100vh - var(--scenario-header-h)); }
        }
        .sortable-ghost {
            opacity: 0.4;
            background: rgba(0, 246, 255, 0.1);
            border: 2px dashed var(--editor-accent);
        }
        #navigator-tree .sortable-ghost {
            background: rgba(162, 89, 255, 0.15);
            border: 1px dashed var(--editor-primary);
            border-radius: 4px;
        }
        #navigator-tree .sortable-ghost * {
            opacity: 0.5;
        }
        .nav-component-list.empty-drop-zone {
            min-height: 30px;
            background-color: rgba(255, 255, 255, 0.06);
            border: 1px dashed rgba(0, 246, 255, 0.4);
            border-radius: 4px;
            margin-top: 4px;
        }
        .connection-line {
            stroke-width: 2px;
            stroke: var(--editor-primary);
            fill: none;
            stroke-dasharray: 5, 5;
            pointer-events: none;
        }
        .connection-arrow {
            fill: var(--editor-primary);
            pointer-events: none;
        }
        .toggle-checkbox:checked {
            right: 0;
            border-color: #2563eb;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #2563eb;
        }
        /* Compact navigator styles */
        .nav-group-wrapper {
            margin-bottom: 0.5rem; /* 8px */
            padding: 0.25rem; /* 4px */
        }
        .nav-group-header {
            padding: 0.25rem 0.5rem; /* 4px 8px */
        }
        .nav-step-list a, .nav-component-list a {
            padding: 0.25rem 0.5rem; /* 4px 8px */
            font-size: 0.875rem; /* 14px */
        }
        .nav-component-list {
            padding-left: 0.75rem; /* 12px */
            margin-left: 0.5rem; /* 8px */
        }
        .nav-group-controls {
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }
        .nav-group-header:hover .nav-group-controls {
            opacity: 1;
        }
    </style>
</head>
<body class="editor-theme font-sans text-slate-100" data-editor="scenario">
    <header id="scenario-header" class="editor-surface px-4 md:px-8 py-3 border-b border-slate-200/30 flex flex-row flex-nowrap justify-between items-center sticky top-0 z-50 shadow-sm gap-4">
        <h1 class="text-xl md:text-2xl font-bold text-slate-100 flex items-center gap-3 whitespace-nowrap"><i class="fa-solid fa-scroll text-blue-300"></i> Редактор v30.3</h1>
        <div class="controls flex flex-nowrap items-center gap-3 min-w-0">
            <div class="flex items-center gap-2 text-sm">
                <label for="arrow-mode-toggle" class="font-medium text-slate-200">Стрелки:</label>
                <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                    <input type="checkbox" name="arrow-mode-toggle" id="arrow-mode-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                    <label for="arrow-mode-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                </div>
            </div>
            <label for="scenario-select" class="text-sm font-medium text-slate-200">Сценарий:</label>
            <select id="scenario-select" class="form-input w-full sm:w-64 min-w-[160px] max-w-[260px]"></select>
            <button id="delete-scenario-btn" title="Удалить текущий сценарий" class="editor-btn editor-btn-danger">
                <i class="fa-solid fa-trash-can"></i>
            </button>
            <input type="text" id="save-as-filename" placeholder="Сохранить как..." class="form-input w-full sm:w-56 min-w-[160px] max-w-[260px]">
            <button id="save-button" title="Сохранить текущий сценарий" class="editor-btn editor-btn-primary flex items-center gap-2">
                <i class="fa-solid fa-save"></i> Сохранить
            </button>
        </div>
    </header>

    <div class="main-container flex flex-col md:flex-row items-start">
        <aside id="navigator" class="w-full md:w-[350px] editor-surface border-r border-slate-200/30 md:sticky overflow-y-auto flex-shrink-0 z-20">
            <div class="navigator-header p-4 font-semibold border-b border-slate-200/30 editor-surface sticky top-0 z-10 flex justify-between items-center">
                <span class="text-slate-100">Структура сценария</span>
                <button id="add-group-btn" class="editor-btn editor-btn-primary text-sm" title="Создать новую группу">
                    <i class="fa-solid fa-plus"></i> <span>Группа</span>
                </button>
            </div>
            <div id="navigator-tree-root" class="p-2"></div>
        </aside>

        <main id="editor-wrapper" class="flex-grow p-4 md:p-8 relative editor-panel">
            <div id="editor-container" class="space-y-8"></div>
             <button id="add-step-button" class="editor-btn editor-btn-primary w-full max-w-3xl mx-auto mt-8">
                <i class="fa-solid fa-plus"></i> Добавить Новый Шаг
            </button>
        </main>
    </div>
    
    <svg id="connections-svg-container" class="fixed top-0 left-0 w-full h-full pointer-events-none z-10"></svg>
    
    <div id="add-component-menu" class="hidden absolute z-[1000] editor-card border border-slate-300/40 shadow-lg rounded-lg p-2 w-72 flex flex-col gap-1"></div>

    <!-- TEMPLATES -->
    <template id="step-card-template">
        <div class="step-card editor-card rounded-lg border border-slate-200/30 shadow-md transition-all duration-200 relative z-10">
            <div class="step-header flex justify-between items-center border-b border-slate-200/30 p-4">
                <div class="title text-lg font-bold text-slate-100 flex items-center gap-3 cursor-grab flex-grow">
                    <i class="fa-solid fa-grip-vertical handle text-slate-400"></i>
                    <i class="fa-solid fa-chevron-down toggle-icon transition-transform cursor-pointer"></i>
                    <span>Шаг ID:</span>
                    <span class="step-id-display font-mono bg-blue-500/20 text-blue-100 text-sm font-medium px-2 py-1 rounded-md"></span>
                </div>
                <div class="step-delay-display hidden text-xs font-medium bg-slate-800/60 text-slate-200 px-2 py-1 rounded-md ml-auto mr-4 items-center gap-1.5"></div>
                <div class="controls-container flex items-center gap-1">
                    <button class="control-btn duplicate-btn w-8 h-8 rounded-full text-slate-300 hover:bg-slate-700/40 hover:text-orange-300 transition-colors" title="Дублировать шаг"><i class="fa-regular fa-copy"></i></button>
                    <button class="control-btn delete-btn w-8 h-8 rounded-full text-slate-300 hover:bg-slate-700/40 hover:text-red-300 transition-colors" title="Удалить шаг"><i class="fa-regular fa-trash-can"></i></button>
                </div>
            </div>
            <div class="step-body p-5 transition-all duration-300">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-medium text-slate-200 mb-1">ID Шага (уникальное, латиницей)</label>
                        <input type="text" class="step-id-input editor-input form-input">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-slate-200 mb-1">Задержка (мс)</label>
                        <input type="number" class="step-delay-input editor-input form-input" placeholder="0">
                    </div>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                    <div>
                        <label class="block text-sm font-medium text-slate-200 mb-1">Информация для игрока (msg_info)</label>
                        <input type="text" class="msg-info-input editor-input form-input" placeholder="Например, 'Найдите выход'">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-slate-200 mb-1">Логика завершения компонентов</label>
                        <select class="completion-logic-select editor-input form-input">
                            <option value="all_of">Все (all_of)</option>
                            <option value="any_of">Любой (any_of)</option>
                            <option value="sequential">Последовательно (sequential)</option>
                        </select>
                    </div>
                </div>
                <div class="components-container mt-5 pt-5 border-t border-dashed border-slate-200/30">
                    <h4 class="font-bold text-slate-100 mb-2">Компоненты</h4>
                </div>
                <button class="add-button add-component-btn w-full mt-4 py-2 bg-slate-800/70 text-slate-100 font-semibold rounded-lg hover:bg-slate-700 transition-colors flex items-center justify-center gap-2">
                    <i class="fa-solid fa-puzzle-piece"></i> Добавить компонент
                </button>
            </div>
        </div>
    </template>

    <template id="component-item-template">
        <div class="component-item editor-card border border-slate-200/30 p-3 rounded-md mb-2 flex justify-between items-center cursor-grab">
            <div class="component-info flex-grow flex items-center gap-3">
                <i class="component-icon text-slate-300 text-lg"></i>
                <div class="component-text-wrapper">
                    <div class="component-type text-sm font-bold uppercase text-slate-200"></div>
                    <div class="component-summary text-sm text-slate-300 mt-0.5"></div>
                </div>
            </div>
            <div class="controls-container flex items-center gap-1">
                <button class="control-btn edit-btn w-8 h-8 rounded-full text-slate-300 hover:bg-slate-700/40 hover:text-blue-300 transition-colors" title="Редактировать"><i class="fa-solid fa-pencil"></i></button>
                <button class="control-btn duplicate-btn w-8 h-8 rounded-full text-slate-300 hover:bg-slate-700/40 hover:text-orange-300 transition-colors" title="Дублировать"><i class="fa-regular fa-copy"></i></button>
                <button class="control-btn delete-btn w-8 h-8 rounded-full text-slate-300 hover:bg-slate-700/40 hover:text-red-300 transition-colors" title="Удалить"><i class="fa-regular fa-trash-can"></i></button>
            </div>
        </div>
    </template>

    <script src="editor-core/registry.js"></script>
    <script src="editor-core/core.js"></script>
    <script src="editor-core/field-renderer.js"></script>
    <script src="editor-core/db-map.js"></script>
    <script src="editor-core/db.js"></script>
    <script src="editor-core/ui.js"></script>
    <script src="editor-core/ui-manager.js"></script>
    <script src="editor-core/defaults.js"></script>
    <script src="editor-core/utils.js"></script>
    <script src="editor-core/bootstrap.js"></script>
    <script type="module">
        // Fallback: scenario editor depends on EditorCore.bootstrapEditor(), but in some setups editor-core/bootstrap.js may not load.
        // If it's missing, define a compatible version here so the editor keeps working.
        if (typeof window.EditorCore !== "undefined" && typeof window.EditorCore.bootstrapEditor !== "function") {
            window.EditorCore.bootstrapEditor = ({ mode = "scenario" } = {}) => {
                if (!window.EditorCore?.UI) throw new Error("EditorCore.UI is missing. Load ui.js first.");
                if (!window.EditorCore?.defaults) {
                    // Minimal safe defaults (scenario) in case defaults.js also didn't load.
                    window.EditorCore.defaults = { getFieldRenderOptions: () => ({ classes: {} }) };
                }
                if (mode === "event") window.EditorCore.UI.mountEventEditorUI?.();
                else window.EditorCore.UI.mountScenarioEditorUI?.();
                return { fieldRenderOptions: window.EditorCore.defaults.getFieldRenderOptions(mode) };
            };
        }



        class ScenarioEditor {
            constructor() {
                this.bindElements();
                this.initState();
                this.initialize();
            }

            bindElements() {
                this.mainContainer = document.querySelector('.main-container');
                this.editorContainer = document.getElementById('editor-container');
                this.navigatorTree = document.getElementById('navigator-tree');
                this.navigatorElement = document.getElementById('navigator');
                this.connectionsContainer = document.getElementById('connections-svg-container');
                this.addStepButton = document.getElementById('add-step-button');
                this.addGroupButton = document.getElementById('add-group-btn');
                this.scenarioSelect = document.getElementById('scenario-select');
                this.deleteScenarioBtn = document.getElementById('delete-scenario-btn');
                this.saveButton = document.getElementById('save-button');
                this.saveAsInput = document.getElementById('save-as-filename');
                this.toastContainer = document.getElementById('toast-container');
                this.arrowModeToggle = document.getElementById('arrow-mode-toggle');
                this.modal = { backdrop: document.getElementById('modal-backdrop'), title: document.getElementById('modal-title'), formContainer: document.getElementById('modal-form-container'), saveButton: document.getElementById('modal-save'), cancelButton: document.getElementById('modal-cancel'), context: null };
                this.deleteGroupModal = {
                    backdrop: document.getElementById('delete-group-modal-backdrop'),
                    cancelBtn: document.getElementById('delete-group-cancel-btn'),
                    deleteOnlyBtn: document.getElementById('delete-group-only-btn'),
                    deleteAndStepsBtn: document.getElementById('delete-group-and-steps-btn'),
                    contextGroupId: null
                };
                this.addComponentMenu = { element: document.getElementById('add-component-menu'), targetStepId: null };
                this.templates = { step: document.getElementById('step-card-template'), component: document.getElementById('component-item-template') };
            }

            initState() {
                this.arrowMode = 'navigator'; // 'navigator' or 'editor'
                this.scenarioData = { steps: [], editor_data: { groups: [] } };
                this.uiState = { collapsedSteps: new Set() }; // Save UI state like collapsed cards
                this.componentTypes = EditorCore.schemas.componentSchemas;
                this.debouncedUpdate = EditorCore.utils.debounce((step, newId) => this.updateStepId(step, newId), 400);
                this.sortableInstances = [];
                this.isTicking = false; // For scroll throttling
                this.apiBase = ""; // auto-detected base path to api.php
            }

            apiUrl(queryString = '') {
                const qs = queryString ? (queryString.startsWith('?') || queryString.startsWith('&') ? queryString : '?' + queryString) : '';
                return `${this.apiBase}api.php${qs}`;
            }

            async resolveApiBase() {
                // Try a few likely relative paths until api.php responds.
                const candidates = ['', './', '../', '../../', '../../../', '../../../../'];
                for (const base of candidates) {
                    try {
                        const url = `${base}api.php?action=list`;
                        const res = await fetch(url, { cache: 'no-store' });
                        if (!res) continue;
                        // Accept any non-404 response; best is 200 OK with JSON.
                        if (res.status !== 404) {
                            // If it's OK, lock it in immediately
                            if (res.ok) {
                                this.apiBase = base;
                                return;
                            }
                            // If it's e.g. 405/500, still likely correct path — keep it but don't early-return
                            this.apiBase = base;
                        }
                    } catch (_) {
                        
                    }
                }
                // Fallback: keep empty. The subsequent requests will show the real HTTP status.
            }


            async initialize() {
                this.addEventListeners();
                await this.resolveApiBase();
                await this.loadScenarioList();
            }

            addEventListeners() {
                this.saveButton.addEventListener('click', () => this.saveScenario());
                this.scenarioSelect.addEventListener('change', () => this.loadScenario(this.scenarioSelect.value));
                this.addStepButton.addEventListener('click', () => this.addNewStep());
                this.addGroupButton.addEventListener('click', () => this.addNewGroup());
                this.deleteScenarioBtn.addEventListener('click', () => this.deleteScenario());
                this.modal.saveButton.addEventListener('click', () => this.saveModalChanges());
                this.modal.cancelButton.addEventListener('click', () => this.closeModal());
                this.modal.backdrop.addEventListener('click', (e) => { if (e.target === this.modal.backdrop) this.closeModal(); });
                this.modal.formContainer.addEventListener('click', (e) => {
                    const listButton = e.target.closest('[data-list-action]');
                    if (listButton) {
                        e.preventDefault();
                        this.handleModalListAction(listButton);
                    }
                });
                document.addEventListener('click', (e) => { if (!e.target.closest('.add-component-btn') && !this.addComponentMenu.element.contains(e.target)) this.hideAddComponentMenu(); });
                this.addComponentMenu.element.addEventListener('click', (e) => this.handleAddComponentAction(e));

                // Delete Group Modal Listeners
                this.deleteGroupModal.cancelBtn.addEventListener('click', () => this.closeDeleteGroupModal());
                this.deleteGroupModal.backdrop.addEventListener('click', (e) => { if(e.target === this.deleteGroupModal.backdrop) this.closeDeleteGroupModal(); });
                this.deleteGroupModal.deleteOnlyBtn.addEventListener('click', () => this.handleDeleteGroup(false));
                this.deleteGroupModal.deleteAndStepsBtn.addEventListener('click', () => this.handleDeleteGroup(true));


                this.arrowModeToggle.addEventListener('change', (e) => {
                    this.arrowMode = e.target.checked ? 'editor' : 'navigator';
                    this.drawConnections();
                });

                const handleEditorEvent = (e) => {
                    const stepCard = e.target.closest('.step-card');
                    if (!stepCard) return;
                    const stepId = stepCard.dataset.stepId;
                    const componentItem = e.target.closest('.component-item');
                    const componentId = componentItem?.dataset.componentId;

                    if (e.type === 'click') {
                        if (e.target.closest('.delete-btn')) this.handleDelete(stepId, componentId);
                        else if (e.target.closest('.duplicate-btn')) this.handleDuplicate(stepId, componentId);
                        else if (e.target.closest('.edit-btn')) this.openEditModal(stepId, componentId);
                        else if (e.target.closest('.add-component-btn')) this.showAddComponentMenu(e.target, stepId);
                        else if (e.target.closest('.toggle-icon')) {
                            const isCollapsed = stepCard.querySelector('.step-body').classList.toggle('hidden');
                            e.target.closest('.toggle-icon').classList.toggle('rotate-[-90deg]', isCollapsed);
                            if (isCollapsed) {
                                this.uiState.collapsedSteps.add(stepId);
                            } else {
                                this.uiState.collapsedSteps.delete(stepId);
                            }
                            this.drawConnections();
                        }
                    } else if (e.type === 'dblclick' && componentId) {
                        this.openEditModal(stepId, componentId);
                    } else if (e.type === 'input') {
                        const step = this.findStep(stepId);
                        if (!step) return;
                        if (e.target.matches('.step-id-input')) this.debouncedUpdate(step, e.target.value);
                        else if (e.target.matches('.msg-info-input')) step.msg_info = e.target.value;
                        else if (e.target.matches('.step-delay-input')) {
                            step.delay = Number(e.target.value) || 0;
                            this.updateStepDelayDisplay(stepCard, step.delay);
                        } else if (e.target.matches('.component-delay-input')) {
                            const component = this.findComponent(stepId, componentId);
                            if (component) {
                                component.delay = Number(e.target.value) || 0;
                            }
                        }
                    } else if (e.type === 'change') {
                        const step = this.findStep(stepId);
                        if (!step) return;
                        if (e.target.matches('.completion-logic-select')) {
                            const value = e.target.value;
                            if (value === 'any_of' || value === 'sequential') {
                                step.completion_logic = value;
                            } else {
                                delete step.completion_logic;
                            }
                            this.renderAll(); // Re-render to show/hide component delays
                        }
                    }
                };

                ['click', 'dblclick', 'input', 'change'].forEach(eventType => {
                    this.editorContainer.addEventListener(eventType, handleEditorEvent);
                });

                // Use a throttled approach for smoother arrow updates on scroll
                window.addEventListener('scroll', () => {
                    if (!this.isTicking) {
                        window.requestAnimationFrame(() => {
                            this.drawConnections();
                            this.isTicking = false;
                        });
                        this.isTicking = true;
                    }
                }, true);
                window.addEventListener('resize', EditorCore.utils.debounce(() => this.drawConnections(), 50));
            }

            renderAll() {
                const { groups, ungroupedSteps } = this.getCurrentViewState();
                this.editorContainer.innerHTML = '';
                
                if (this.scenarioData.steps.length === 0) {
                    this.renderEmptyState();
                    this.renderNavigator();
                    return;
                }
                
                const stepMap = new Map(this.scenarioData.steps.map(s => [s.id, s]));
                const renderedSteps = new Set();

                // Render grouped steps first, in the order defined by viewState
                groups.forEach(group => {
                    const groupWrapper = document.createElement('div');
                    groupWrapper.className = 'step-group-container mb-8';
                    
                    if (!group.isDefault && group.steps.length > 0) {
                        const titleEl = document.createElement('h3');
                        titleEl.className = 'text-center text-lg font-semibold text-slate-500 tracking-wider uppercase pt-4 pb-2 mb-4 border-b border-slate-200';
                        titleEl.textContent = group.name;
                        groupWrapper.appendChild(titleEl);
                    }

                    const stepListContainer = document.createElement('div');
                    stepListContainer.className = 'step-group bg-slate-500/70 p-4 rounded-xl border border-slate-600/80 space-y-8 relative z-0';
                    stepListContainer.dataset.groupId = group.id;

                    group.steps.forEach(stepId => {
                        const step = stepMap.get(stepId);
                        if (step && !renderedSteps.has(stepId)) {
                            try {
                                stepListContainer.appendChild(this.createStepElement(step));
                                renderedSteps.add(stepId);
                            } catch (error) {
                                console.error(`Error rendering step ${stepId}:`, error);
                                stepListContainer.appendChild(this.createErrorStepElement(step, error));
                            }
                        }
                    });
                    
                    if (stepListContainer.children.length > 0) {
                        groupWrapper.appendChild(stepListContainer);
                        this.editorContainer.appendChild(groupWrapper);
                    }
                });

                // Render ungrouped steps
                const ungroupedContainer = document.createElement('div');
                ungroupedContainer.className = 'step-group bg-slate-700/70 p-4 rounded-xl border border-slate-800/80 space-y-8 relative z-0';
                ungroupedContainer.dataset.groupId = 'ungrouped';
                
                ungroupedSteps.forEach(stepId => {
                    const step = stepMap.get(stepId);
                    if (step && !renderedSteps.has(stepId)) {
                         try {
                            ungroupedContainer.appendChild(this.createStepElement(step));
                            renderedSteps.add(stepId);
                        } catch (error) {
                            console.error(`Error rendering ungrouped step ${stepId}:`, error);
                            ungroupedContainer.appendChild(this.createErrorStepElement(step, error));
                        }
                    }
                });

                if (ungroupedContainer.children.length > 0) {
                    this.editorContainer.appendChild(ungroupedContainer);
                }
                
                this.renderNavigator();
                this.initAllSortables();
                requestAnimationFrame(() => this.drawConnections());
                this.validateAllStepIds();
            }

            renderEmptyState() {
                this.editorContainer.innerHTML = `<div class="text-center p-20 my-5 max-w-3xl mx-auto bg-white border-2 border-dashed border-slate-300 rounded-xl"><i class="fa-solid fa-wand-magic-sparkles text-slate-400 text-5xl mb-4"></i><h2 class="text-2xl font-bold text-slate-800">Сценарий пока пуст</h2><p class="text-slate-500 mt-2 mb-6">Начните творить, добавив первый шаг с помощью большой зеленой кнопки ниже.</p></div>`;
            }

            createStepElement(step) {
                const stepCard = this.templates.step.content.cloneNode(true).firstElementChild;
                stepCard.id = `step-card-${step.id}`;
                stepCard.dataset.stepId = step.id;
                stepCard.querySelector('.step-id-display').textContent = step.id;
                stepCard.querySelector('.step-id-input').value = step.id;
                stepCard.querySelector('.step-delay-input').value = step.delay || '';
                this.updateStepDelayDisplay(stepCard, step.delay);
                stepCard.querySelector('.msg-info-input').value = step.msg_info || '';
                stepCard.querySelector('.completion-logic-select').value = step.completion_logic || 'all_of';
                const componentsContainer = stepCard.querySelector('.components-container');
                (Array.isArray(step.components) ? step.components : (step.components = [])).filter(Boolean).forEach((comp, index) => {
                    if (!comp.component_id) comp.component_id = this.generateUUID();
                    componentsContainer.appendChild(this.createComponentElement(comp, step, index));
                });
                
                if (this.uiState.collapsedSteps.has(step.id)) {
                    stepCard.querySelector('.step-body').classList.add('hidden');
                    stepCard.querySelector('.toggle-icon').classList.add('rotate-[-90deg]');
                }

                return stepCard;
            }

            updateStepDelayDisplay(stepCard, delay) {
                const display = stepCard.querySelector('.step-delay-display');
                if (delay > 0) {
                    display.innerHTML = `<i class="fa-solid fa-stopwatch"></i> ${delay} мс`;
                    display.classList.remove('hidden');
                    display.classList.add('flex');
                } else {
                    display.classList.add('hidden');
                    display.classList.remove('flex');
                }
            }

            createErrorStepElement(stepData, error) {
                const stepCard = this.templates.step.content.cloneNode(true).firstElementChild;
                stepCard.classList.add('border-red-500', 'bg-red-50');
                const id = stepData?.id || 'ID_НЕ_УКАЗАН';
                stepCard.id = `step-card-error-${id}`;
                stepCard.dataset.stepId = id;
                stepCard.querySelector('.step-id-display').textContent = id;
                const body = stepCard.querySelector('.step-body');
                body.innerHTML = `<h4 class="font-bold text-red-700">Ошибка рендеринга шага</h4><p class="text-sm text-red-600 mt-2">Этот шаг не удалось отобразить. Возможно, данные в файле сценария повреждены. <br><b>Сообщение:</b> ${error.message}</p><p class="text-xs mt-2">Вы можете удалить этот шаг, чтобы исправить сценарий.</p>`;
                stepCard.querySelector('.duplicate-btn')?.remove();
                return stepCard;
            }

            createComponentElement(component, step, index) {
                const item = this.templates.component.content.cloneNode(true).firstElementChild;
                item.id = `component-item-${component.component_id}`;
                item.dataset.componentId = component.component_id;
                
                const info = this.componentTypes[component.type] || { class: 'info', name: component.type, icon: 'fa-solid fa-question-circle' };
                item.querySelector('.component-icon').className = `component-icon ${info.icon}`;
                item.querySelector('.component-type').textContent = info.name;
                item.querySelector('.component-summary').innerHTML = this.getComponentSummary(component);
                
                const colorClass = { info: 'border-l-blue-500', interactive: 'border-l-orange-500', combat: 'border-l-red-500', camera: 'border-l-teal-500' }[info.class] || 'border-l-slate-500';
                item.classList.add('border-l-4', colorClass);

                if (step.completion_logic === 'sequential') {
                    const orderSpan = document.createElement('span');
                    orderSpan.className = 'mr-2 font-bold text-slate-500';
                    orderSpan.textContent = `${index + 1}.`;
                    item.querySelector('.component-info').prepend(orderSpan);

                    const delayWrapper = document.createElement('div');
                    delayWrapper.className = 'mt-2 flex items-center gap-2';
                    delayWrapper.innerHTML = `<label class="text-xs font-medium text-slate-600">Задержка (мс):</label>
                                            <input type="number" class="component-delay-input editor-input form-input w-24 text-sm" value="${component.delay || 0}">`;
                    item.querySelector('.component-text-wrapper').appendChild(delayWrapper);
                }

                return item;
            }

            renderNavigator() {
                const { groups, ungroupedSteps } = this.getCurrentViewState();
                const container = document.createDocumentFragment();
                const stepMap = new Map(this.scenarioData.steps.map(s => [s.id, s]));

                groups.forEach(group => {
                    const groupWrapper = this.createNavGroupElement(group);
                    const stepList = groupWrapper.querySelector('.nav-step-list');
                    
                    group.steps.forEach(stepId => {
                        const step = stepMap.get(stepId);
                        if (step) stepList.appendChild(this.createNavStepElement(step));
                    });
                    
                    container.appendChild(groupWrapper);
                });

                const ungroupedWrapper = this.createNavGroupElement({ id: 'ungrouped', name: 'Шаги без группы', collapsed: false, isDefault: true });
                const ungroupedList = ungroupedWrapper.querySelector('.nav-step-list');
                
                ungroupedSteps.forEach(stepId => {
                     const step = stepMap.get(stepId);
                     if (step) ungroupedList.appendChild(this.createNavStepElement(step));
                });
                container.appendChild(ungroupedWrapper);

                this.navigatorTree.innerHTML = '';
                this.navigatorTree.appendChild(container);
                
                this.addNavigatorEventListeners();
            }

            createNavGroupElement(group) {
                const groupWrapper = document.createElement('div');
                groupWrapper.className = 'nav-group-wrapper mb-2 bg-slate-600/50 rounded-lg p-1';
                groupWrapper.dataset.groupId = group.id;

                const header = document.createElement('div');
                header.className = 'nav-group-header flex items-center justify-between p-2 cursor-pointer';
                
                const titleWrapper = document.createElement('div');
                titleWrapper.className = 'flex items-center gap-2';

                const toggleIcon = document.createElement('i');
                toggleIcon.className = `fa-solid fa-chevron-down text-slate-500 transition-transform duration-200 ${group.collapsed ? 'rotate-[-90deg]' : ''}`;
                
                const title = document.createElement('span');
                title.className = 'font-bold text-slate-100';
                title.textContent = group.name;
                if (!group.isDefault) {
                    title.contentEditable = true;
                    title.addEventListener('click', (e) => e.stopPropagation());
                    title.addEventListener('blur', (e) => this.renameGroup(group.id, e.target.textContent));
                    title.addEventListener('keydown', (e) => { 
                        if(e.key === 'Enter') {
                            e.preventDefault();
                            e.target.blur(); 
                        }
                    });
                }

                titleWrapper.append(toggleIcon, title);

                const controls = document.createElement('div');
                if (!group.isDefault) {
                    controls.className = 'nav-group-controls flex items-center gap-2';
                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'text-slate-400 hover:text-orange-500 w-6 h-6 rounded flex items-center justify-center';
                    copyBtn.innerHTML = '<i class="fa-regular fa-copy"></i>';
                    copyBtn.title = 'Копировать группу';
                    copyBtn.onclick = (e) => {
                        e.stopPropagation();
                        this.duplicateGroup(group.id);
                    };
                    controls.appendChild(copyBtn);

                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'text-slate-400 hover:text-red-500 w-6 h-6 rounded flex items-center justify-center';
                    deleteBtn.innerHTML = '<i class="fa-solid fa-times"></i>';
                    deleteBtn.title = 'Удалить группу';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        this.openDeleteGroupModal(group.id);
                    };
                    controls.appendChild(deleteBtn);
                }

                header.append(titleWrapper, controls);
                header.onclick = () => this.toggleGroupCollapse(group.id);

                const stepList = document.createElement('ul');
                stepList.className = 'nav-step-list pl-2';
                if (group.collapsed) {
                    stepList.classList.add('hidden');
                }
                
                groupWrapper.append(header, stepList);
                return groupWrapper;
            }

            createNavStepElement(step) {
                const allStepIds = new Set(this.scenarioData.steps.map(s => s.id));
                const stepLi = document.createElement('li');
                stepLi.dataset.stepId = step.id;

                const nextStepInfo = ''; // Removed from navigator view
                const componentCount = step.components?.length || 0;
                const componentInfo = `<span class="text-xs font-normal text-slate-300">(${componentCount} комп.)</span>`;
                
                stepLi.innerHTML = `<a href="#step-card-${step.id}" data-nav-id="${step.id}" class="flex items-center p-1.5 rounded-md border-b border-transparent hover:bg-slate-700/40"><i class="fa-solid fa-grip-vertical nav-handle text-slate-400 hover:text-slate-200 mr-2 cursor-grab"></i><div class="flex-grow flex justify-between items-center font-semibold text-slate-100 text-sm">
                                            <span class="flex items-center gap-2">${step.id || '<i>Без ID</i>'} ${componentInfo}</span>
                                            ${nextStepInfo}
                                        </div>
                                    </a>`;
                
                const compUl = document.createElement('ul');
                compUl.className = 'nav-component-list pl-4 ml-3 border-l border-slate-200/30';
                compUl.dataset.parentStepId = step.id;
                EditorCore.UI.applyEmptyStateClass(compUl, (step.components || []).length > 0, 'empty-drop-zone');
                
                (step.components || []).filter(Boolean).forEach(comp => {
                    const compLi = document.createElement('li');
                    compLi.dataset.componentId = comp.component_id;
                    const isCompBroken = comp.next_step_id && !allStepIds.has(comp.next_step_id);
                    const compNextStep = comp.next_step_id ? `<span class="text-xs font-normal text-purple-300">${isCompBroken ? '⚠️' : '→'} ${comp.next_step_id}</span>` : '';
                    compLi.innerHTML = `<a href="#step-card-${step.id}" data-nav-id="${comp.component_id}" class="flex items-center p-1.5 rounded-md border-b border-transparent hover:bg-slate-700/40 text-sm"><i class="fa-solid fa-grip-vertical nav-handle text-slate-400 hover:text-slate-200 mr-2 cursor-grab"></i><div class="flex-grow flex justify-between items-center text-slate-200">
                                                <span>↳ ${comp.type}</span>
                                                ${compNextStep}
                                            </div>
                                        </a>`;
                    compUl.appendChild(compLi);
                });
                stepLi.appendChild(compUl);
                return stepLi;
            }

            addNavigatorEventListeners() {
                this.navigatorTree.querySelectorAll('a').forEach(anchor => {
                    anchor.addEventListener('click', (e) => {
                        if (e.target.closest('.nav-handle')) return;
                        e.preventDefault();
                        const targetElement = document.querySelector(anchor.getAttribute('href'));
                        if (targetElement) {
                            targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            document.querySelectorAll('.step-card.ring-2').forEach(el => el.classList.remove('ring-2', 'ring-blue-500'));
                            targetElement.classList.add('ring-2', 'ring-blue-500');
                            setTimeout(() => targetElement.classList.remove('ring-2', 'ring-blue-500'), 1500);
                        }
                    });
                });
            }

            drawConnections() {
                this.connectionsContainer.innerHTML = '';
                if (!this.scenarioData.steps) return;

                this.scenarioData.steps.forEach(step => {
                    (step.components || []).filter(Boolean).forEach(comp => {
                        if (comp?.next_step_id) {
                            this.drawSingleConnection(comp.component_id, comp.next_step_id);
                        }
                    });
                });
            }

            drawSingleConnection(sourceElementId, targetStepId) {
                const toStepCard = document.getElementById(`step-card-${targetStepId}`);
                if (!toStepCard) return;

                let fromElement;
                if (this.arrowMode === 'navigator') {
                    fromElement = document.querySelector(`[data-nav-id="${sourceElementId}"]`);
                } else {
                    const sourceStepId = this.findComponentStepId(sourceElementId) || sourceElementId;
                    const sourceStepCard = document.getElementById(`step-card-${sourceStepId}`);
                    if (sourceStepCard) {
                         const isSourceCollapsed = sourceStepCard.querySelector('.step-body').classList.contains('hidden');
                         fromElement = document.getElementById(`component-item-${sourceElementId}`);
                         if (!fromElement || isSourceCollapsed) {
                            fromElement = sourceStepCard;
                         }
                    }
                }

                if (!fromElement) return;

                const fromRect = fromElement.getBoundingClientRect();
                const toRect = toStepCard.getBoundingClientRect();

                let startX, startY, endX, endY, controlX1, controlX2;

                startY = fromRect.top + fromRect.height / 2;
                endY = toRect.top + toRect.height / 2;

                if (this.arrowMode === 'navigator') {
                    startX = fromRect.right;
                    endX = toRect.left;
                    controlX1 = startX + 60;
                    controlX2 = endX - 60;
                } else { // editor mode
                    startX = fromRect.left;
                    endX = toRect.left;
                    const offset = 60;
                    controlX1 = startX - offset;
                    controlX2 = endX - offset;
                }

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', `M ${startX} ${startY} C ${controlX1} ${startY}, ${controlX2} ${endY}, ${endX} ${endY}`);
                path.classList.add('connection-line');
                
                const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                arrow.setAttribute('points', `${endX},${endY} ${endX - 10},${endY - 5} ${endX - 10},${endY + 5}`);
                arrow.classList.add('connection-arrow');

                this.connectionsContainer.appendChild(path);
                this.connectionsContainer.appendChild(arrow);
            }
            
            addNewStep() {
                const newId = this.generateUniqueId('step');
                const newStep = { id: newId, components: [] };
                this.scenarioData.steps.push(newStep);
                
                this.addStepToViewState(newId);

                this.renderAll();
                const newCard = document.getElementById(`step-card-${newId}`);
                newCard?.scrollIntoView({ behavior: 'smooth', block: 'center' });
                newCard?.querySelector('.step-id-input')?.focus();
            }

            handleDelete(stepId, componentId) {
                if (componentId) {
                    if (!confirm("Вы уверены, что хотите удалить этот компонент?")) return;
                    const step = this.findStep(stepId);
                    if (step) step.components = step.components.filter(c => c.component_id !== componentId);
                } else {
                    if (!confirm(`Вы уверены, что хотите удалить шаг "${stepId}"?`)) return;
                    this.scenarioData.steps = this.scenarioData.steps.filter(s => s.id !== stepId);
                    this.removeStepFromViewState(stepId);
                }
                this.renderAll();
            }

            handleDuplicate(stepId, componentId) {
                if (componentId) {
                    const step = this.findStep(stepId);
                    const component = this.findComponent(stepId, componentId);
                    if (step && component) {
                        const componentIndex = step.components.findIndex(c => c.component_id === componentId);
                        const newComponent = JSON.parse(JSON.stringify(component));
                        newComponent.component_id = this.generateUUID();
                        step.components.splice(componentIndex + 1, 0, newComponent);
                    }
                } else {
                    const step = this.findStep(stepId);
                    if (step) {
                        const stepIndex = this.scenarioData.steps.findIndex(s => s.id === stepId);
                        const newStep = JSON.parse(JSON.stringify(step));
                        newStep.id = this.generateUniqueId(step.id);
                        (newStep.components || []).forEach(c => c.component_id = this.generateUUID());
                        this.scenarioData.steps.splice(stepIndex + 1, 0, newStep);
                        this.addStepToViewState(newStep.id, stepId);
                    }
                }
                this.renderAll();
            }

            updateStepId(stepToUpdate, newId) {
                const oldId = stepToUpdate.id;
                if (oldId === newId || !newId) return;
                
                const isUnique = !this.scenarioData.steps.some(s => s.id === newId);
                if (!isUnique) {
                    this.showToast(`ID "${newId}" уже используется!`, 'error');
                    this.validateAllStepIds(); 
                    return;
                }

                stepToUpdate.id = newId;
                this.scenarioData.steps.forEach(s => {
                    (s.components || []).forEach(c => {
                        if (c.next_step_id === oldId) c.next_step_id = newId;
                    });
                });
                this.updateStepIdInViewState(oldId, newId);
                this.renderAll();
            }

            openEditModal(stepId, componentId) {
                const component = this.findComponent(stepId, componentId);
                if (!component) return;
                const step = this.findStep(stepId);
                this.modal.context = { stepId, componentId, data: JSON.parse(JSON.stringify(component)) };
                const componentInfo = this.componentTypes[component.type] || { name: component.type };
                this.modal.title.textContent = `Редактирование: ${componentInfo.name}`;
                this.modal.formContainer.innerHTML = this.buildModalForm(this.modal.context.data, step);
                // IMPORTANT: modal content is dynamic. Re-run Core init so db_select, validation, toggles, etc. work.
                Promise.resolve().then(() => window.EditorCore?.UIManager?.init?.(this.modal.formContainer));
                this.modal.backdrop.classList.remove('hidden');
                this.modal.formContainer.querySelector('input, textarea, select')?.focus();
            }

            closeModal() {
                this.modal.backdrop.classList.add('hidden');
                this.modal.context = null;
            }

            saveModalChanges() {
                if (!this.modal.context) return;
                const editedData = this.collectModalFormData();
                if (editedData.type === 'defeat_mobs') {
                    if (editedData.mode !== 'survival') delete editedData.duration;
                    if (editedData.mode !== 'wave') delete editedData.kill_target;
                }

                const originalComponent = this.findComponent(this.modal.context.stepId, this.modal.context.componentId);
                Object.assign(originalComponent, editedData);

                if (originalComponent.type === 'door_control' && originalComponent.action === 'remove') {
                    delete originalComponent.position;
                }

                this.closeModal();
                this.renderAll();
            }

            collectModalFormData() {
                const form = this.modal.formContainer.querySelector('form');
                const editedData = JSON.parse(JSON.stringify(this.modal.context.data));
                const schemaFields = this.componentTypes[editedData.type]?.fields || {};
                Object.entries(schemaFields).forEach(([key, field]) => {
                    if (field.type === 'list') editedData[key] = [];
                });
                form.querySelectorAll('[name]').forEach((input) => {
                    const value = window.EditorCore.FieldRenderer.getInputValue(input);
                    window.EditorCore.FieldRenderer.setValueAtPath(editedData, input.name, value);
                });
                return editedData;
            }

            handleModalListAction(button) {
                if (!this.modal.context) return;
                const step = this.findStep(this.modal.context.stepId);
                const listPath = button.dataset.listPath;
                if (!listPath) return;
                const currentData = this.collectModalFormData();
                const listValue = window.EditorCore.FieldRenderer.getValueAtPath(currentData, listPath) || [];
                if (button.dataset.listAction === 'add') {
                    const defaultItemRaw = button.dataset.listDefault ? decodeURIComponent(button.dataset.listDefault) : null;
                    const defaultItem = defaultItemRaw ? JSON.parse(defaultItemRaw) : {};
                    listValue.push(defaultItem);
                } else if (button.dataset.listAction === 'remove') {
                    const index = parseInt(button.dataset.listIndex);
                    if (!Number.isNaN(index)) listValue.splice(index, 1);
                }
                window.EditorCore.FieldRenderer.setValueAtPath(currentData, listPath, listValue);
                this.modal.context.data = currentData;
                this.modal.formContainer.innerHTML = this.buildModalForm(currentData, step);
                // Re-init Core enhancements for newly rendered list rows.
                Promise.resolve().then(() => window.EditorCore?.UIManager?.init?.(this.modal.formContainer));
            }

            buildModalForm(data, step) {
                const renderOptions = window.EditorCore.defaults.getFieldRenderOptions('scenario');
                renderOptions.listAddLabel = 'Добавить элемент';

                let formHtml = `<form onsubmit="return false;"><label class="${renderOptions.classes.label}">Переход к шагу (если нужно):</label>`;
                const select = document.createElement('select');
                select.name = 'next_step_id';
                select.className = renderOptions.classes.input;
                this.populateStepDropdown(select, data.next_step_id);
                formHtml += select.outerHTML;

                // Show delay for sequential logic OR for follow_camera
                const shouldShowDelay = data.type === 'follow_camera' || (step && step.completion_logic === 'sequential');
                const componentSchema = this.componentTypes[data.type] || {};
                const componentFields = componentSchema.fields || {};
                const filteredFields = Object.fromEntries(Object.entries(componentFields).filter(([key]) => key !== 'next_step_id'));

                if (shouldShowDelay && !filteredFields.delay) {
                    const delayField = { type: 'number', label: 'Задержка (мс)', ui: { min: 0, max: 600000 } };
                    formHtml += window.EditorCore.FieldRenderer.renderField({ path: 'delay', field: delayField, data, options: renderOptions });
                }

                formHtml += `<hr class="my-5 border-slate-700/40">`;
                formHtml += window.EditorCore.FieldRenderer.renderFields({
                    fields: filteredFields,
                    data,
                    options: renderOptions
                });
                formHtml += `</form>`;

                setTimeout(() => {
                    if (data.type === 'door_control') {
                        const actionSelect = this.modal.formContainer.querySelector('select[name="action"]');
                        const positionFields = this.modal.formContainer.querySelector('[data-field-path="position"]');
                        if (actionSelect && positionFields) {
                            actionSelect.addEventListener('change', (e) => {
                                positionFields.classList.toggle('hidden', e.target.value === 'remove');
                            });
                        }
                    }
                    if (data.type === 'defeat_mobs') {
                        const modeSelect = this.modal.formContainer.querySelector('select[name="mode"]');
                        const killTargetField = this.modal.formContainer.querySelector('[data-field-path="kill_target"]');
                        const durationField = this.modal.formContainer.querySelector('[data-field-path="duration"]');
                        const toggleModeFields = () => {
                            if (killTargetField) killTargetField.classList.toggle('hidden', modeSelect?.value !== 'wave');
                            if (durationField) durationField.classList.toggle('hidden', modeSelect?.value !== 'survival');
                        };
                        modeSelect?.addEventListener('change', toggleModeFields);
                        toggleModeFields();
                    }
                }, 0);
                return formHtml;
            }

            async loadScenarioList() {
                try {
                    const response = await fetch(this.apiUrl('action=list'));
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const data = await response.json();
                    if (data.success && data.files.length > 0) {
                        this.scenarioSelect.innerHTML = data.files.map(file => `<option value="${file}">${file}</option>`).join('');
                        await this.loadScenario(data.files[0]);
                    } else this.loadScenarioData({ steps: [], editor_data: { groups: [] } }, 'new_scenario.json');
                } catch (error) {
                    this.showToast(`Ошибка загрузки списка: ${error.message}`, 'error');
                }
            }
            async loadScenario(filename) {
                if (!filename) return;
                try {
                    const response = await fetch(this.apiUrl(`file=${filename}`));
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const data = await response.json();
                    if (data.error) throw new Error(data.error);
                    this.loadScenarioData(data, filename);
                    this.showToast(`Сценарий "${filename}" загружен.`, 'success');
                } catch (error) {
                    this.showToast(`Ошибка загрузки сценария: ${error.message}`, 'error');
                    this.loadScenarioData({ steps: [], editor_data: { groups: [] } }, filename); // Load empty state on error
                }
            }
            loadScenarioData(data, filename) {
                if (!data || !Array.isArray(data.steps)) {
                    this.showToast("Ошибка: формат файла сценария некорректен.", "error");
                    this.scenarioData = { steps: [], editor_data: { groups: [] } };
                } else {
                    this.scenarioData = {
                        steps: data.steps,
                        editor_data: data.editor_data || { groups: [] }
                    };
                    this.scenarioData.steps.forEach((step, index) => {
                        if (!step || typeof step !== 'object') step = { id: `invalid_step_${index}` };
                        if (!step.id) step.id = this.generateUniqueId(`step_${index}`);
                        (step.components || []).forEach(c => {
                            this.applyComponentDefaults(c);
                            if (!c.component_id) c.component_id = this.generateUUID();
                        });
                    });
                }
                this.uiState.collapsedSteps.clear(); // Clear old state on new scenario load
                this.renderAll();
            }
            async saveScenario() {
                if (!this.validateAllStepIds()) return this.showToast('Есть шаги с некорректными ID. Исправьте!', 'error');
                let filename = this.saveAsInput.value.trim() || this.scenarioSelect.value;
                if (!filename) return this.showToast('Введите имя файла для сохранения!', 'error');
                if (!filename.endsWith('.json')) filename += '.json';
                
                const stepMap = new Map(this.scenarioData.steps.map(s => [s.id, s]));
                const orderedSteps = [];
                
                this.scenarioData.editor_data.groups.forEach(group => {
                    group.steps.forEach(stepId => {
                        const step = stepMap.get(stepId);
                        if (step) {
                            orderedSteps.push(step);
                        }
                    });
                });
                
                const stepsInGroups = new Set(orderedSteps.map(s => s.id));

                // Preserve manual order for ungrouped steps (if user dragged them).
                const ed = this.scenarioData.editor_data || {};
                const ungroupedOrder = Array.isArray(ed.ungrouped_steps) ? ed.ungrouped_steps : [];
                ungroupedOrder.forEach(stepId => {
                    if (stepsInGroups.has(stepId)) return;
                    const step = stepMap.get(stepId);
                    if (step) {
                        orderedSteps.push(step);
                        stepsInGroups.add(step.id);
                    }
                });

                // Fallback: append any remaining steps
                this.scenarioData.steps.forEach(step => {
                    if (!stepsInGroups.has(step.id)) {
                        orderedSteps.push(step);
                    }
                });

                const stepsToSave = JSON.parse(JSON.stringify(orderedSteps));

                stepsToSave.forEach(step => {
                    (step.components || []).forEach(c => {
                        delete c.component_id;
                        if (!c.next_step_id) {
                            delete c.next_step_id;
                        }
                        if (c.type !== 'follow_camera' && (step.completion_logic !== 'sequential' || !c.delay)) {
                            delete c.delay;
                        } else if (c.type === 'follow_camera' && !c.delay) {
                            delete c.delay;
                        }
                    });
                    if (!step.delay) {
                        delete step.delay;
                    }
                    if (step.completion_logic === 'all_of') {
                        delete step.completion_logic;
                    }
                    if (!step.msg_info) {
                        delete step.msg_info;
                    }
                });

                const contentToSave = {
                    editor_data: this.scenarioData.editor_data,
                    steps: stepsToSave
                };
                
                try {
                    const response = await fetch(this.apiUrl(), { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filename, content: contentToSave }) });
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const result = await response.json();
                    if (result.success) {
                        this.showToast(result.message, 'success');
                        const isNewFile = !Array.from(this.scenarioSelect.options).some(opt => opt.value === filename);
                        if (isNewFile) {
                            const option = document.createElement('option');
                            option.value = filename;
                            option.textContent = filename;
                            this.scenarioSelect.appendChild(option);
                        }
                        this.scenarioSelect.value = filename;
                        this.saveAsInput.value = '';
                    } else this.showToast(result.error, 'error');
                } catch (error) {
                    this.showToast(`Ошибка сохранения: ${error.message}`, 'error');
                }
            }

            async deleteScenario() {
                const filename = this.scenarioSelect.value;
                if (!filename || !confirm(`Вы уверены, что хотите удалить сценарий "${filename}"? Это действие необратимо.`)) return;

                try {
                    const response = await fetch(this.apiUrl(), { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ action: 'delete', filename }) });
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const result = await response.json();
                    if (result.success) {
                        this.showToast(result.message, 'success');
                        await this.resolveApiBase();
                await this.loadScenarioList();
                    } else {
                        this.showToast(result.error, 'error');
                    }
                } catch (error) {
                    this.showToast(`Ошибка удаления: ${error.message}`, 'error');
                }
            }

            showToast(message, type = 'success') {
                // Unified toast for all editors.
                EditorCore.utils.showToast(message, type);
            }
            findStep(stepId) { return this.scenarioData.steps.find(s => s.id === stepId); }
            findComponent(stepId, componentId) { return this.findStep(stepId)?.components.find(c => c.component_id === componentId); }
            findComponentStepId(componentId) {
                for (const step of this.scenarioData.steps) {
                    if (step.components?.some(c => c.component_id === componentId)) {
                        return step.id;
                    }
                }
                return null;
            }
            generateUniqueId(base) {
                let newId = base.replace(/[^a-zA-Z0-9_]/g, '') || 'step';
                let counter = 1;
                const allIds = new Set(this.scenarioData.steps.map(s => s.id));
                while (allIds.has(newId)) newId = `${base}_${counter++}`;
                return newId;
            }
            generateUUID() { return EditorCore.utils.uuid(); }
            populateStepDropdown(select, selectedValue, excludeId = null) {
                select.innerHTML = `<option value="">-- Не выбрано --</option>` + this.scenarioData.steps.filter(s => s.id !== excludeId).map(s => `<option value="${s.id}" ${s.id === selectedValue ? 'selected' : ''}>${s.id}</option>`).join('');
            }
            validateAllStepIds() {
                const ids = new Map();
                let allValid = true;
                this.editorContainer.querySelectorAll('.step-id-input').forEach(input => {
                    const currentId = input.value.trim();
                    input.classList.remove('ring-2', 'ring-red-500');
                    if (!currentId || !/^[a-zA-Z0-9_]+$/.test(currentId) || ids.has(currentId)) {
                        input.classList.add('ring-2', 'ring-red-500');
                        allValid = false;
                        if (ids.has(currentId)) ids.get(currentId).classList.add('ring-2', 'ring-red-500');
                    } else ids.set(currentId, input);
                });
                return allValid;
            }
            collectAllDoorKeys() {
                const keys = new Set();
                this.scenarioData.steps.forEach(step => {
                    (step.components || []).forEach(data => {
                        if (data.type === 'door_control' && data.action === 'create' && data.key) {
                            keys.add(data.key);
                        }
                    });
                });
                return Array.from(keys);
            }
            applyComponentDefaults(component) {
                const schema = this.componentTypes[component.type];
                if (schema?.fields) {
                    EditorCore.schemas.applyDefaults(component, schema.fields);
                }
                return component;
            }
            createComponentDefaults(type) {
                const schema = this.componentTypes[type];
                const defaults = schema?.fields ? EditorCore.schemas.buildDefaults(schema.fields) : {};
                return { type, ...defaults };
            }
            getComponentSummary(data) {
                try {
                    switch (data.type) {
                        case 'message': return `"${(data.text || '').substring(0, 50)}..."`;
                        case 'door_control': return `Действие: <b>${data.action}</b>, Ключ: <b>${data.key || 'нет'}</b>`;
                        case 'use_chat_code': return `Код: "<b>${data.code}</b>", переход → <b>${data.next_step_id || '?'}</b>`;
                        case 'defeat_mobs': return `Режим: <b>${data.mode || 'annihilation'}</b>, ${data.mobs?.length || 0} групп(ы)`;
                        case 'wait': return `Ожидание: <b>${data.duration}</b> сек.`;
                        case 'follow_camera': return `К точке (<b>${data.position?.x}, ${data.position?.y}</b>), ${data.smooth ? 'плавно' : 'резко'}`;
                        case 'condition_movement': return `Прийти в точку (<b>${data.position?.x}, ${data.position?.y}</b>), ${data.entire_group ? 'вся группа' : 'один игрок'}`;
                        case 'teleport': return `В точку (<b>${data.position?.x}, ${data.position?.y}</b>)`;
                        case 'activate_point': return `Текст: "<b>${data.action_text || ''}</b>", Время: <b>${data.duration}</b> сек.`;
                        default: return ``;
                    }
                } catch { return "Ошибка в данных"; }
            }

            //==================================================
            // VIEW STATE MANAGEMENT (Groups, Collapse State)
            //==================================================
            getCurrentViewState() {
                const ed = this.scenarioData.editor_data || (this.scenarioData.editor_data = {});
                ed.groups = Array.isArray(ed.groups) ? ed.groups : [];
                ed.ungrouped_steps = Array.isArray(ed.ungrouped_steps) ? ed.ungrouped_steps : [];

                const groups = ed.groups;
                const stepsInGroups = new Set();
                groups.forEach(g => (g.steps || []).forEach(stepId => stepsInGroups.add(stepId)));

                const allStepIds = (this.scenarioData.steps || []).map(s => s?.id).filter(Boolean);
                const allIdSet = new Set(allStepIds);

                // Prefer stored order for ungrouped steps, but keep it clean.
                const ungroupedSet = new Set();
                const ungroupedSteps = [];

                (ed.ungrouped_steps || []).forEach(id => {
                    if (allIdSet.has(id) && !stepsInGroups.has(id) && !ungroupedSet.has(id)) {
                        ungroupedSet.add(id);
                        ungroupedSteps.push(id);
                    }
                });

                // Append any missing ungrouped steps in natural (scenarioData.steps) order.
                allStepIds.forEach(id => {
                    if (!stepsInGroups.has(id) && !ungroupedSet.has(id)) {
                        ungroupedSet.add(id);
                        ungroupedSteps.push(id);
                    }
                });

                // Persist the cleaned order so dragging inside "Шаги без группы" stays stable.
                ed.ungrouped_steps = ungroupedSteps.slice();

                return { groups, ungroupedSteps };
            }
            
            addNewGroup() {
                const groups = this.scenarioData.editor_data.groups;
                const newGroup = {
                    id: `group_${this.generateUUID()}`,
                    name: `Новая группа ${groups.length + 1}`,
                    steps: [],
                    collapsed: false
                };
                groups.push(newGroup);
                this.renderAll();
            }
            
            openDeleteGroupModal(groupId) {
                this.deleteGroupModal.contextGroupId = groupId;
                this.deleteGroupModal.backdrop.classList.remove('hidden');
            }

            closeDeleteGroupModal() {
                this.deleteGroupModal.contextGroupId = null;
                this.deleteGroupModal.backdrop.classList.add('hidden');
            }

            handleDeleteGroup(deleteSteps) {
                const groupId = this.deleteGroupModal.contextGroupId;
                if (!groupId) return;

                const groups = this.scenarioData.editor_data.groups;
                const groupIndex = groups.findIndex(g => g.id === groupId);
                if (groupIndex > -1) {
                    if (deleteSteps) {
                        const stepsToDelete = new Set(groups[groupIndex].steps);
                        this.scenarioData.steps = this.scenarioData.steps.filter(s => !stepsToDelete.has(s.id));
                    }
                    groups.splice(groupIndex, 1);
                    this.renderAll();
                }
                this.closeDeleteGroupModal();
            }

            duplicateGroup(groupId) {
                const groups = this.scenarioData.editor_data.groups;
                const sourceGroupIndex = groups.findIndex(g => g.id === groupId);
                if (sourceGroupIndex === -1) return;

                const sourceGroup = groups[sourceGroupIndex];
                const newGroup = JSON.parse(JSON.stringify(sourceGroup));
                
                newGroup.id = `group_${this.generateUUID()}`;
                newGroup.name = `${sourceGroup.name} (копия)`;
                newGroup.steps = [];

                const idMap = new Map();

                sourceGroup.steps.forEach(stepId => {
                    const sourceStep = this.findStep(stepId);
                    if (sourceStep) {
                        const newStep = JSON.parse(JSON.stringify(sourceStep));
                        newStep.id = this.generateUniqueId(sourceStep.id);
                        idMap.set(sourceStep.id, newStep.id);
                        
                        (newStep.components || []).forEach(c => c.component_id = this.generateUUID());
                        
                        this.scenarioData.steps.push(newStep);
                        newGroup.steps.push(newStep.id);
                    }
                });

                newGroup.steps.forEach(newStepId => {
                    const newStep = this.findStep(newStepId);
                    (newStep.components || []).forEach(c => {
                        if (c.next_step_id && idMap.has(c.next_step_id)) {
                            c.next_step_id = idMap.get(c.next_step_id);
                        }
                    });
                });

                groups.splice(sourceGroupIndex + 1, 0, newGroup);
                this.renderAll();
            }

            toggleGroupCollapse(groupId) {
                const groups = this.scenarioData.editor_data.groups;
                const group = groups.find(g => g.id === groupId);
                if (group) {
                    group.collapsed = !group.collapsed;
                    this.renderNavigator();
                    this.initAllSortables(); 
                    requestAnimationFrame(() => this.drawConnections());
                }
            }
            
            renameGroup(groupId, newName) {
                const groups = this.scenarioData.editor_data.groups;
                const group = groups.find(g => g.id === groupId);
                if (group && group.name !== newName) {
                    group.name = newName;
                    this.renderAll();
                }
            }

            addStepToViewState(stepId, afterStepId) {
                const groups = this.scenarioData.editor_data.groups;
                let targetGroup = null;
                let targetIndex = -1;

                if (afterStepId) {
                    for (const group of groups) {
                        const idx = group.steps.indexOf(afterStepId);
                        if (idx > -1) {
                            targetGroup = group;
                            targetIndex = idx + 1;
                            break;
                        }
                    }
                }

                if (targetGroup) {
                    targetGroup.steps.splice(targetIndex, 0, stepId);
                } else {
                    let firstGroup = groups.find(g => !g.isDefault);
                    if (firstGroup) {
                        firstGroup.steps.push(stepId);
                    }
                }
            }
            
            removeStepFromViewState(stepId) {
                const groups = this.scenarioData.editor_data.groups;
                groups.forEach(g => {
                    const index = g.steps.indexOf(stepId);
                    if (index > -1) {
                        g.steps.splice(index, 1);
                    }
                });
            }

            updateStepIdInViewState(oldId, newId) {
                const groups = this.scenarioData.editor_data.groups;
                groups.forEach(g => {
                    const index = g.steps.indexOf(oldId);
                    if (index > -1) {
                        g.steps[index] = newId;
                    }
                });
            }

            initAllSortables() {
                this.sortableInstances.forEach(s => s.destroy());
                this.sortableInstances = [];

                const sortableConfig = (groupName, onEndCallback, handleClass, extra = {}) => ({
                    group: groupName,
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    handle: handleClass,
                    ...extra,
                    onEnd: onEndCallback
                });
                
                const createOnEndHandler = (callback) => (e) => {
                    callback(e);
                    requestAnimationFrame(() => this.renderAll());
                };
                
                // Sort Groups in Navigator
                // NOTE: navigator also renders an implicit "ungrouped" section which should not be draggable.
                const onEndGroupSort = createOnEndHandler(() => {
                    const ed = this.scenarioData.editor_data || (this.scenarioData.editor_data = {});
                    ed.groups = Array.isArray(ed.groups) ? ed.groups : [];
                    const domIds = Array.from(this.navigatorTree.querySelectorAll('.nav-group-wrapper'))
                        .map(el => el?.dataset?.groupId)
                        .filter(id => id && id !== 'ungrouped');
                    const byId = new Map(ed.groups.map(g => [g.id, g]));
                    ed.groups = domIds.map(id => byId.get(id)).filter(Boolean);
                });
                this.sortableInstances.push(new Sortable(
                    this.navigatorTree,
                    sortableConfig('groups', onEndGroupSort, '.nav-group-header', {
                        draggable: '.nav-group-wrapper:not([data-group-id="ungrouped"])'
                    })
                ));

                // Sort steps in editor (between groups)
                document.querySelectorAll('.step-group').forEach(listEl => {
                    const onEnd = createOnEndHandler(e => {
                        const stepId = e.item?.dataset?.stepId;
                        if (!stepId) return;

                        const toGroupId = e.to?.dataset?.groupId;
                        const ed = this.scenarioData.editor_data || (this.scenarioData.editor_data = {});
                        const viewStateGroups = Array.isArray(ed.groups) ? ed.groups : (ed.groups = []);
                        ed.ungrouped_steps = Array.isArray(ed.ungrouped_steps) ? ed.ungrouped_steps : [];

                        // Remove step from any group
                        viewStateGroups.forEach(group => {
                            const idx = (group.steps || []).indexOf(stepId);
                            if (idx > -1) group.steps.splice(idx, 1);
                        });

                        // Also remove from stored ungrouped order before re-inserting
                        const uIdx = ed.ungrouped_steps.indexOf(stepId);
                        if (uIdx > -1) ed.ungrouped_steps.splice(uIdx, 1);

                        if (toGroupId && toGroupId !== 'ungrouped') {
                            const targetGroup = viewStateGroups.find(g => g.id === toGroupId);
                            if (targetGroup) {
                                const newDomOrder = Array.from(e.to.children).map(el => el?.dataset?.stepId).filter(Boolean);
                                targetGroup.steps = newDomOrder;
                            }
                        } else {
                            // Reorder ungrouped steps exactly as DOM shows
                            const newDomOrder = Array.from(e.to.children).map(el => el?.dataset?.stepId).filter(Boolean);
                            ed.ungrouped_steps = newDomOrder;
                        }
                    });
                    this.sortableInstances.push(new Sortable(listEl, sortableConfig('steps', onEnd, '.handle', { draggable: '.step-card' })));
                });

                // Sort components within steps (in editor)
                document.querySelectorAll('.components-container').forEach(containerEl => {
                    const onEnd = createOnEndHandler(e => {
                        const fromStepId = e.from?.closest('.step-card')?.dataset?.stepId;
                        const toStepId = e.to?.closest('.step-card')?.dataset?.stepId;
                        const componentId = e.item?.dataset?.componentId;
                        if (!fromStepId || !toStepId || !componentId) return;

                        const fromStep = this.findStep(fromStepId);
                        const toStep = this.findStep(toStepId);
                        if (!fromStep || !toStep) return;

                        fromStep.components = Array.isArray(fromStep.components) ? fromStep.components.filter(Boolean) : [];
                        toStep.components = Array.isArray(toStep.components) ? toStep.components.filter(Boolean) : [];

                        const oldIndex = fromStep.components.findIndex(c => c?.component_id === componentId);
                        if (oldIndex < 0) return;

                        const [moved] = fromStep.components.splice(oldIndex, 1);
                        if (!moved) return;

                        const newDomOrder = Array.from(e.to.querySelectorAll('.component-item')).map(el => el?.dataset?.componentId).filter(Boolean);
                        const newIndex = Math.max(0, newDomOrder.indexOf(componentId));
                        toStep.components.splice(newIndex, 0, moved);

                        // Final safety: never keep holes
                        fromStep.components = fromStep.components.filter(Boolean);
                        toStep.components = toStep.components.filter(Boolean);
                    });
                    this.sortableInstances.push(new Sortable(containerEl, sortableConfig('components', onEnd, '.component-item', {
                        draggable: '.component-item',
                        filter: 'h4',
                        preventOnFilter: false
                    })));
                });
                
                // Sort steps in navigator
                document.querySelectorAll('.nav-step-list').forEach(listEl => {
                    const onEnd = createOnEndHandler(e => {
                        const stepId = e.item?.dataset?.stepId;
                        if (!stepId) return;

                        const toGroupId = e.to?.closest('.nav-group-wrapper')?.dataset?.groupId;
                        const ed = this.scenarioData.editor_data || (this.scenarioData.editor_data = {});
                        const viewStateGroups = Array.isArray(ed.groups) ? ed.groups : (ed.groups = []);
                        ed.ungrouped_steps = Array.isArray(ed.ungrouped_steps) ? ed.ungrouped_steps : [];

                        viewStateGroups.forEach(group => {
                            const idx = (group.steps || []).indexOf(stepId);
                            if (idx > -1) group.steps.splice(idx, 1);
                        });

                        const uIdx = ed.ungrouped_steps.indexOf(stepId);
                        if (uIdx > -1) ed.ungrouped_steps.splice(uIdx, 1);

                        if (toGroupId && toGroupId !== 'ungrouped') {
                            const targetGroup = viewStateGroups.find(g => g.id === toGroupId);
                            if (targetGroup) {
                                const newDomOrder = Array.from(e.to.children).map(li => li?.dataset?.stepId).filter(Boolean);
                                targetGroup.steps = newDomOrder;
                            }
                        } else {
                            const newDomOrder = Array.from(e.to.children).map(li => li?.dataset?.stepId).filter(Boolean);
                            ed.ungrouped_steps = newDomOrder;
                        }
                    });
                    this.sortableInstances.push(new Sortable(listEl, sortableConfig('nav-steps', onEnd, '.nav-handle', { draggable: 'li' })));
                });

                // Sort components in navigator
                document.querySelectorAll('.nav-component-list').forEach(l => {
                    const onEnd = createOnEndHandler(e => {
                        const fromStepId = e.from?.dataset?.parentStepId;
                        const toStepId = e.to?.dataset?.parentStepId;
                        const fromStep = this.findStep(fromStepId);
                        const toStep = this.findStep(toStepId);
                        if (!fromStep || !toStep) return;

                        const componentId = e.item?.dataset?.componentId;
                        if (!componentId) return;

                        fromStep.components = Array.isArray(fromStep.components) ? fromStep.components.filter(Boolean) : [];
                        toStep.components = Array.isArray(toStep.components) ? toStep.components.filter(Boolean) : [];

                        const oldCompIndex = fromStep.components.findIndex(c => c?.component_id === componentId);
                        if (oldCompIndex < 0) return;

                        const [moved] = fromStep.components.splice(oldCompIndex, 1);
                        if (!moved) return;

                        const newCompArray = Array.from(e.to.children).map(li => li?.dataset?.componentId).filter(Boolean);
                        const newCompIndex = newCompArray.indexOf(componentId);
                        toStep.components.splice(newCompIndex < 0 ? toStep.components.length : newCompIndex, 0, moved);

                        fromStep.components = fromStep.components.filter(Boolean);
                        toStep.components = toStep.components.filter(Boolean);
                    });
                    this.sortableInstances.push(new Sortable(l, sortableConfig('components', onEnd, '.nav-handle', { draggable: 'li' })));
                });
            }
            showAddComponentMenu(button, stepId) {
                const rect = button.getBoundingClientRect();
                this.addComponentMenu.targetStepId = stepId;
                const menu = this.addComponentMenu.element;
                menu.innerHTML = Object.entries(this.componentTypes).map(([type, info]) =>
                    `<div class="context-menu-item flex items-center gap-3 p-2 rounded-md hover:bg-slate-700/40 cursor-pointer" data-type="${type}"><i class="${info.icon} w-5 text-center text-slate-200"></i><div><div class="font-semibold text-slate-100">${info.name}</div><div class="text-xs text-slate-300">${info.desc}</div></div></div>`
                ).join('');
                menu.style.top = `${rect.bottom + window.scrollY + 5}px`;
                menu.style.left = `${rect.left + window.scrollX}px`;
                menu.classList.remove('hidden');
            }
            hideAddComponentMenu() { this.addComponentMenu.element.classList.add('hidden'); }
            handleAddComponentAction(e) {
                const item = e.target.closest('.context-menu-item');
                if (!item) return;
                const type = item.dataset.type;
                const step = this.findStep(this.addComponentMenu.targetStepId);
                if (type && step) {
                    const newComponent = this.createComponentDefaults(type);
                    newComponent.component_id = this.generateUUID();
                    step.components = step.components || [];
                    step.components.push(newComponent);
                    this.renderAll();
                }
                this.hideAddComponentMenu();
            }
        }
        const ScenarioApp = EditorCore.createEditorApp({
            id: 'scenario-editor',
            state: {},
            init: async (app) => {
                EditorCore.bootstrapEditor({ mode: 'scenario' });
                EditorCore.UI.mountListContainer({
                    id: 'navigator-tree',
                    parent: document.getElementById('navigator-tree-root'),
                    className: 'space-y-2'
                });
                app.state.editor = new ScenarioEditor();
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            ScenarioApp.mount();

            // Sync CSS var with actual header height (fixes top bar/layout when it wraps).
            const header = document.getElementById('scenario-header');
            const setHeaderVar = () => {
                if (!header) return;
                document.documentElement.style.setProperty('--scenario-header-h', `${header.offsetHeight}px`);
            };
            setHeaderVar();
            const throttled = window.EditorCore?.utils?.rafThrottle ? window.EditorCore.utils.rafThrottle(setHeaderVar) : setHeaderVar;
            window.addEventListener('resize', throttled);
            // In case fonts load late
            setTimeout(setHeaderVar, 50);
        });
    </script>
</body>
</html>
